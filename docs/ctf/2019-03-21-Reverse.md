
[TOC]
# TODO
unicorn
https://www.hetianlab.com/cour.do?w=1&c=CCID660c-8b63-44e9-929e-5a1edef2e2bd
https://www.52pojie.cn/thread-1026209-1-1.html
https://mp.weixin.qq.com/s/mqXF9jpULSAFp3VyeJoVSA


# 工具环境配置
[Reverse Engineering with Ghidra_](https://bbs.pediy.com/thread-250805.htm)
[Reverse Engineering Tutorial](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)
[IDA如何patch掉花指令？](https://bbs.pediy.com/thread-263323.htm)
[The Ghidra book - The Definitive Guide [Complete]](https://bbs.pediy.com/thread-262585.htm)
[《Windows PE权威指南》](https://bbs.pediy.com/thread-263552.htm)
[Ghidra操作手册](https://www.kanxue.com/book-section_list-64.htm)

[综合 | CTF逆向指南](https://mp.weixin.qq.com/s/SBtFqLNjXzl55WvtBmPtPw)

[逆向工程工具集_2020年11月23日更新：V1.1](https://bbs.pediy.com/thread-263443.htm)
# Q1 

x64dbg 载入后为什么不在入口 在7xxxx地址。

# 逆向

## 解题思路
输入 0000,1111 测试同字符的变化是不是线性
查看关键引用, 按x查看w写入的部分

执行顺序 libc_start开始执行。  init,start,fini
        init  中可能修改libc got进行hook 替换。可能要简单看下
        ---   调用要看汇编, 传参可能有多个函数地址，
        ---   Shift+F7, 定位 .fini_array 查看
Ctrl+Alt+F, 先Findcrypt,然后返回F5，再继续查看。

求解类的可以倒着计算，从结果开始反推。

1. winhex直接搜flag

2. 用 die/exeinfo pe 查壳。

        ELF文件，用winhex打开搜下是不是upx
        如果提示 yoda's Protector, 有可能是UPX壳， 扔到 winhex 搜到UPX，搜到为UPX壳。

    2.1 如果是upx用upx -d filename 脱壳

2. 没壳拖入IDA和OD

    Ctrl+S 看rdata段
    遇到 __debugbreak() 汇编窗口看是 int ,3 ， 可能需要nop掉。
    v3 == 125 这种, IDA中按R转成字符看看。
                        也可能是按A转换成字符串

3. 常见断点 GetDlgItemTextA, printf

4. OD/gdb 直接改jmp跳转到flag。见 xctf game
3. IDA直接改EIP跳转到flag。见下面

3. 脱壳：
       用x64/x32dbg(不用od) ,走几步一个大跳。就开脱。插件 Scylla, IAT自动搜索。
             1. 不使用结果。
             2. 导入中删除无效指针
             3. 转储 4.PE重建 5.修复转储

4. 逆向分析, v9 = 'wodah'; 小端存储注意, join时需要反序
   -- 注意 strncpy(d,s,nsize) 注意size大小, 可能被缩小要手动放大
   -- 找到加密字符, 用16进制看一下。是不是可能为迷宫。
   -- 开头`flag{xxxx}`可以用flag,{}来猜异或解密
5. 代码分析
   -- a2[v7] | 0x20 表示大写转小写
   -- (a2[v7] | 0x20) - 87;  字符转16进制int , a=>10
   -- 时间戳  可能是附近的，需要暴破
5. .net文件分析
   -- dnspy 动态调试/修改代码, 资源可以右击看16进制, 或右击直接保存
5. 暴破angr, ponce
   -- 单位比较有提示, 爆破

6. apk: 
   -- 1.jadx
   -- 2.点击smali 看源码, 反编译的可能不全。源码全点
7. js/uniapp jadx解压出来后, 搜索 `[\da-fA-F,]+`
   -- https://jsdec.js.org/
7. jar: jeb, jd-gui
         jd-gui加编码  java -D'file.encoding='=utf-8 -jar .\jd-gui-1.6.6.jar exercise2.jar
8. pyc文件 uncompyle6 -o pcat.py pcat.pyc
9. smc自解码  羊城杯2021 BabySmc, BUUCTF-re-[GWCTF 2019]re3 smc,
1. vm虚拟机 
     -- 信号量处理 见 ### 信号量处理
9. 内置文件及操作 resource hacker 查看 见 ### Buuoj/CrackRTF
1. 迷宫题目
   -- [迷宫问题的三种求解方法](https://blog.csdn.net/m0_37870649/article/details/105096303)
   -- [求解迷宫问题的三种方法(python实现)](https://blog.csdn.net/qq_29681777/article/details/83719680)
1. firmware  - firmware-mod-kit/ 见下面 # Firmware

### Go语言的逆向

多看asm窗口，字符变量比较明显

### VB/MFC

1. 查看  OnInit 函数
2. 搜索 MessageBoxW 函数
3. 搜索 window , callWindowProcW, CreateWindowExW

EnableWindow 没隐藏 , MoveWindow, ShowWindow分析

4. PostMessageW 

断点---
https://mp.weixin.qq.com/s/seTVPrbeN7pGRFk0F4Zdnw
Bp GetDlgItemTextA

### 代码阅读/IDAC

byte型保留0xff，可以用 `& 0xff` 或 `% 0x100`

++*((_QWORD *)result + 2); QWORD型(8bytes) +2相当于 +了2个QWORD长度, 即 result地址+16

#### MD5

```c
CryptCreateHash(phProv, 0x8003u, 0, 0, &phHash) 
```

### C/C++/CPP
operator[](v6,i);

```c
// int a[6];
v6[i]
```

异或32, F^0x20 == F^32 == f 是转换大小写
        {^32==[
#### vc, winform, dialog, windows API
消息类型 WM_XXXX, 都保存在 VC98\Include\WINUSER.H

WM_INITDIALOG                   0x0110
WM_COMMAND 0x111
WM_LBUTTONUP                    0x0202
WM_RBUTTONUP                    0x0205
WM_MBUTTONUP                    0x0208

wParam == 104 , wParam 可以用 Resource Hacker/VC++以资源形式  载入来看Menu等找到对应的104信息。
https://in1t.top/2020/11/28/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89/#findKey-x86-exe-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2-%E8%8A%B1%E6%8C%87%E4%BB%A4

Resource Hacker - 查看 wParam
### printf
https://en.cppreference.com/w/cpp/io/c/fprintf
print long
```c
printf("%lu", 5ul);
```
for int %d

For long int %ld

For long long int %lld

For unsigned long long int %llu
### 数据处理
大整数注意可能是小端存储，要倒序过来。

wchar_t 16位或32位。

## 实战/题目类型

红帽杯 easyre https://blog.csdn.net/Tokameine/article/details/118191966

### 迷宫题 -maze
```
as[10*dword_407034+dword_407030] == 'F'
```
10是列宽

[关于Python-Maze模块的学习](https://ppppz.net/2022/02/07/%E5%85%B3%E4%BA%8EPython-Maze%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AD%A6%E4%B9%A0/)


### smc自解码
羊城杯2021 BabySmc, BUUCTF-re-[GWCTF 2019]re3 smc,
https://blog.csdn.net/qq_41923479/article/details/80377708
https://blog.csdn.net/Palmer9/article/details/105034093/


phantom https://www.bilibili.com/video/BV1ZT4y1o7H8

mprotect 修改权限可以改代码了。  ida按个c就能变code， 按p变函数, 然后就能f5了。
按y 可改类型 char*
### 反调试技术/混淆/修复

https://ctf-wiki.org/reverse/windows/anti-debug/ntglobalflag/
#### 反调试检测
https://mp.weixin.qq.com/s/i2kQ8uBkPI4qglGQvangmQ
1.IsDebuggerPresent函数
2.NeQueryInfomationProcess函数
3.CheckRemoteDebuggerPresent函数
4.FindWindowA、EnumWindows
5.OutputDebigString函数
SetLastError的错误码一致，如果没有被调试，那么错误码可能是任意值。
6.注册表检测
7.BeginDebugged标志检测
8.检测ProcessHead标志
9.检测NTGlobalFlag标志
10.检测父进程是否是explorer.exe
#### div eax //eax=0
第四届2021美团网络安全高校挑战赛 Random

除以0此时会跳转到下一段汇编
```
00F81144   .  33C0          xor eax,eax
00F81146   .  F7F0          div eax                                                     ; eax=0, 除以0出错这里出错跳转
00F81148   .  C745 FC FEFFF>mov dword ptr ss:[ebp-0x4],-0x2
00F8114F   .  8B3D CC20F800 mov edi,dword ptr ds:[<&api-ms-win-crt-u>;  ucrtbase.rand
00F81155   .  EB 22         jmp short Random.00F81179
00F81157   .  B8 01000000   mov eax,0x1
00F8115C   .  C3            retn
00F8115D   .  8B65 E8       mov esp,dword ptr ss:[ebp-0x18]                             ; 跳到这里
00F81160   .  8B3D CC20F800 mov edi,dword ptr ds:[<&api-ms-win-crt-u>;  ucrtbase.rand
```
#### 反调试/Linux/ptrace/getppid
1.ptrace  - nop掉
2.cat /proc/self/status , 非调试时 tracepid 为0
3.父进程检测 getppid 父进程是gdb, strace或者  ltrace说明在被调试
```
strace -o a.txt cat /proc/self/status
```

#### 32位调用64位程序, cs, retf
https://www.sohu.com/a/297638567_750628
在x64系统下的进程是有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。

* 32位模式时，CS = 0x23；
* 64位模式时，CS = 0x33。

第四届2021美团网络安全高校挑战赛wow.zip

如果此时栈中有0x33，则会将0x33弹出到CS寄存器中，实现32位程序切换到64位代码的过程。参考wp可复制到新文件拖入ida64恢复为C代码。

__所以retf是识别32位程序调用64位代码的重要标志。__

#### 修复function endp/smc -- [GWCTF 2019]re3
1.smc解密
```python
from ida_bytes import  *
addr = 0x402219
for i in range(224):
    a = addr + i
    patch_byte(a, get_byte(a) ^ 0x99)
```
2.g 0x402219 再选中 0x402219到0x0402220 这段加密过的按U，再按P
3.  004021F5这段还是红色，ida不认识。g 004021F5，按p
##### edit function 修复sp
但是 main 函数报了错两种方法修复
0000004021E9 main            endp ; sp-analysis failed (Alt+K)
1.main的 endp出错下方的函数 全部按u, 直到0x402220, 右击main, edit function修改到0x402220。然后在分析的代码处点击按C。
2.main包含的全部函数按u,按u, 回到main头部0x402219, 按p

### 虚拟机vm
#### 信号量处理
[东软-暗泉杯-DUNICTF2021_EasyRe.zip](https://mp.weixin.qq.com/s/KgxHOFH52EE8z7NnMTSIDA)
https://or4ngesec.github.io/post/dnuictf-writeup-by-or4nge/#easyre

文档 https://www.man7.org/linux/man-pages/man2/sigaction.2.html

```c
int sub_40144B()
{
 struct sigaction v1; // [rsp+0h] [rbp-140h] BYREF
 struct sigaction v2; // [rsp+A0h] [rbp-A0h] BYREF
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_400E1D;
 v2.sa_flags = 4;
 sigaction(34, &v2, &v1);
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_400E78;
 v2.sa_flags = 4;
 sigaction(35, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_400ED7;
 v2.sa_flags = 0;
 sigaction(36, &v2, &v1);
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_400F16;
 v2.sa_flags = 4;
 sigaction(37, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_400F67;
 v2.sa_flags = 0;
 sigaction(38, &v2, &v1);
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_400FA8;
 v2.sa_flags = 4;
 sigaction(39, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_400FFB;
 v2.sa_flags = 0;
 sigaction(40, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_40103A;
 v2.sa_flags = 0;
 sigaction(41, &v2, &v1);
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_401089;
 v2.sa_flags = 4;
 sigaction(42, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_4010EA;
 v2.sa_flags = 0;
 sigaction(43, &v2, &v1);
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_40113A;
 v2.sa_flags = 4;
 sigaction(44, &v2, &v1);
 sigemptyset(&v2.sa_mask);
 v2.sa_handler = (__sighandler_t)sub_40116C;
 v2.sa_flags = 4;
 sigaction(45, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_4011AD;
 v2.sa_flags = 0;
 sigaction(46, &v2, &v1);
 v2.sa_handler = (__sighandler_t)sub_40120D;
 v2.sa_flags = 0;
 return sigaction(47, &v2, &v1);
}
```


### Buuoj/CrackRTF
https://blog.csdn.net/DALE1186487104/article/details/97016976
https://blog.csdn.net/qq_42967398/article/details/96492843

## 查看文件信息

Linux下 file xxxx

## Tools
python/pyc 反编译 https://github.com/rocky/python-uncompyle6/releases
winhex, 工具 - 打开RAM，可以修改内存

IDA https://www.chinapyg.com/forum.php?mod=viewthread&tid=142494
BinDiff https://storage.googleapis.com/bindiff-releases/updated-20210607/bindiff7.msi
DynamoRIO 8.0.18895 windows 版 https://github.com/DynamoRIO/dynamorio/releases
lighthouse https://github.com/gaasedelen/lighthouse
frida-15.1.17-py3.10-win-amd64.egg https://pypi.org/project/frida/#files
pycdc https://github.com/zrax/pycdc (可自行编译或者用我编译的）
Python 3.10
CMake最新版
VS2022（或者VS2019） 安装时要勾选上“使用C++的桌面开发

## IDA使用
[入门](https://www.52pojie.cn/forum.php?mod=viewthread&tid=886103)

[IDA作者Blog](https://hex-rays.com/blog/)

转换200 单位为String, 右击数据 Array 输入200, 再鼠标选中按A
数据修正 按D 修改字节为1,2,4,8字节,
　　     按A -- Ascii
         按*  Array
         按O Offset 将此处定义为地址偏移
函数修正 起始地址按P
指令修正 按D 修正不会跳转的地址

设置 - Disassembly - auto comments
### IDA环境配置
75之前API差异问题 https://www.52pojie.cn/thread-1403005-1-1.html
[IDA7.5 启动基础配置 ](https://bbs.pediy.com/thread-264346.htm)
```
@rem 7032.bat file for bootstrap ida.exe with py2
@set path=D:\ProgramData\graphviz_my\bin;%path%
@set path=D:\ProgramData\Anaconda2;D:\ProgramData\Anaconda2\Scripts;D:\ProgramData\Anaconda2\Library\bin;D:\ProgramData\Anaconda2\Lib;D:\ProgramData\Anaconda2\DLLs;D:\Program Files\IDA 7.0\python;%path%
@set PYTHONPATH=D:\Python;D:\Python\lib;D:\Python\scripts
@start ida.exe
```
### IDA基础

![20211209074952](imgs/20211209074952.jpg)

蓝色是函数区, 这里鼠标拖拽可移动视图

![20211209075111](imgs/20211209075111.jpg)

绿色True, 红色False

选项  Disassembly选项卡Number of opcode bytes 可填 16就差不多了, 遇到+号说明需要更多bytes解析。

![20211209075711](imgs/20211209075711.jpg)

快速Patch, 1.显示opcode看好对应字节 2. 对应处 Edit-Patch-Change Byte, 填入连续的90

Struct, 在 Structure 窗口定义好Keybank(例) 后, 在反汇编窗口选择变量, 按Y将 int v6修改为 Keybank. Set the type
-- Shift+F9 切换窗口
-- Ins 创建Struct
-- D 在end处添加member/切换大小
-- U 删除member
-- Y 直接定义类型及长度
-- Ctrl+E 扩展增加bytes
-- Ctrl+S 收缩bytes
   -- 练习 tree下的 [WUSTCTF2020]level4/[GUET-CTF2019]number_game, 见 ### 逆向分析学习 - 恢复 Struct
   -- Y或Alt+Q可修改为结构体

View中全部选择: Ctrl+Page up, Ctrl+Shift+Page Down

comment -- 可以用 f_print_key, 即 function print_key()

修改栈值/hex值: 右击Edit(F2), 输入数据, 右击 Apply

cs -- code segment

view - flow chart

双击右侧的XREF也可以跳转
.rdata:00420BC8 aEnglishAus:                            ; DATA XREF: .rdata:004206C4↑o

.data 段的是全局变量
#### 修正数组大小
```c
//[ACTF新生赛2020]easyre
  _BYTE v6[5]; // [esp+2Ah] [ebp-16h] BYREF
  int v7; // [esp+2Fh] [ebp-11h]
  int v8; // [esp+33h] [ebp-Dh]
  int v9; // [esp+37h] [ebp-9h]
  char v10; // [esp+3Bh] [ebp-5h]
  int i; // [esp+3Ch] [ebp-4h]
```
分析后确定 v6是数组, v7v8v9v10不存在, 大小为 0x16-4=0x12=18
方法1. v6处按Y, 改为 `char v6[18]`
方法2. 双击v6, 按*输入18
F5更新视图

### 分析Tips
连续内存看成同一变量, 都是v17
```
__int128 v17;  // [esp+Ch]
__int128 v18;  // [esp+1Ch]
int v19;       // [esp+2Ch]
int v20;       // [esp+30Ch]
__int16 v21;   // [esp+34Ch]
int v22;       // [esp+38h]
```
#### 逆向分析学习 - 恢复 Struct

Struct 恢复练习

方式1
Shift+F1, Insert

```c
struct func
{
  void *call;
  vm *ptr;
};
```

方式2
Shift+F9切换到Enum窗口

按Ins键, 新建 名称 node。

```assembly
00000008 node            ends         ; 光标在这里按d 新建
```

按D新建属性, 再按可切换大小

```assembly
00000000 node            struc ; (sizeof=0x1, mappedto_6)
00000000 field_0         db ?         ; 光标移到这里  按U可删除, 按D可切换大小
00000001 node            ends
```

点击field_0, 按d切换成dq

按N修改名称为cur

再点 node ends, 按d新建left和right, 变成下面这样。

```assembly
00000000 cur dq ?
00000008 left dq ?                               ; XREF: init+7D/w
00000010 right dq ?                              ; XREF: init+122/w
00000018 node ends
```
可以按Y将left, right定义为 node *left, node *right.

切换到汇编窗口， G来到 0x00400800处F5, 即 type1

点击a1按alt+q或者y修改为 node *a1 程序变成这样

```c
__int64 __fastcall type1(node *a1)
{
  __int64 result; // rax

  if ( a1 )
  {
    type1((node *)a1->left);
    putchar(SLOBYTE(a1->cur));
    return type1((node *)a1->right);
  }
  return result;
}
```

#### 逆向分析学习 - 循环/div/test
```
.text:0000000000401551 loc_401551:                             ; CODE XREF: main+3A↓j
.text:0000000000401551                 mov     eax, [rbp+var_4]
.text:0000000000401554                 mov     edx, eax
.text:0000000000401556                 lea     rcx, Format     ; "%d\n"
.text:000000000040155D                 call    printf
.text:0000000000401562                 add     [rbp+var_4], 1
.text:0000000000401566
.text:0000000000401566 loc_401566:                             ; CODE XREF: main+1F↑j
.text:0000000000401566                 cmp     [rbp+var_4], 9
.text:000000000040156A                 jle     short loc_401551
```

div分析
```
mov eax, 168
div esi
cmp esi,eax
jle short CONTINUE

if (i <= n / i )
  continue;
```

test x,1 就是 & 1 即模2和0比较
```c
lea edx, [eax+esi]
test dl, 1
jnz short CONTINUE

int edx = n / i + i;
if (edx % 2 != 0)
  continue
```
### IDA/快捷键
1 恢复 zoom 100%

F6 下个窗口

A Data转为字符串
```
选中多个后按A
db 1
db 0
```

如果运行时会弹2个错误确认，使用F4来运行。

Ctrl + E => 跳到Entry => main

IDA-View 转字串时, 显示不全先D再S
    S 转字串

\ 隐藏转换 *QWORD
H 转16进制
N rename , 再按F5更新
C 16进制变量值转code
P 16进制转函数, 然后就能F5

- Comment
/ line comment
INS block comment
: comment , for Graph view
; repeatable comment, for Graph view

- Search
Alt+B, Bytes Search, 配合opcodes显示使用
     -- 用双引号 可搜索字符 "123" 
Alt+T, Text Search

- Data exploration
A, String
D, 切换显示 word(2 bytes), dword (4 bytes), qword (8 bytes)
U, undefined
P, make function, procedure转函数
C, Convert to code

- Views
Alt+1,2,3 切换对应窗口
  -- Structure视图下
  INS 新建Structure
  D, 在ends行按D新建 field
  N, rename field
  T, 在 Graph View的对象中按T选择Structure
View - Database Snapshot

### 设置

Options-General...-strings 把gb2312 改为UTF-8。点击ok

### 操作

打开hex窗口： View-Open Subviews-
IDA view 右击变量 jump to a new hex window
#### 函数操作
删除函数：在函数窗口中选中函数后，按Delete键。
定义函数：在反汇编窗口中选中对应行后，按P键。
修改函数参数：在函数窗口中选中并按Ctrl＋E组合键，或在反汇编窗口的函数内部按Alt＋P组合键。

### 插件 
keypatch

https://mp.weixin.qq.com/s/96nkW8oFk4w7HMZrKqw6jQ

[Ponce使用方法](https://www.cnblogs.com/wgf4242/p/13064986.html)

https://github.com/illera88/Ponce/actions/runs/115490440

https://github.com/illera88/Ponce/tree/master/latest_builds

https://www.bilibili.com/video/BV1QK411W7ZZ

https://blog.csdn.net/Hotspurs/article/details/106039643
### 常用方式
* 将文件丢入IDA，定位main函数，F5

* 只有一个信息框从弹窗下手

```
    1.搜索message  API：View-Imports ，底下的搜索栏搜 message, 看到MessageBoxW
    2.双击进去，Ctrl+X查看调用，发现没有被调用，于是放过
    3.弹窗有可能为窗口类，搜索window --- ShowWindow
```

连续的定义， 可试着在汇编窗口看。

Feature | Description|Menu|Windows
--|--|--|--
数字转字符 | 右击 - Char, 字串-大端存储的，需倒序。在hex dump里看是正常的 || <kbd>R</kbd>
导出数据 | 双击变量进入, 选中数据后 导出 => C unsign char array decimal |Edit - Export data | <kbd>Shift</kbd> <kbd>E</kbd>
切换变量大小| 双击变量进入的 反汇编数据窗口，点击变量 |右击-Data | <kbd>D</kbd> 可切换 Byte, Word, Dword
显示数组大小| 双击变量进入的 反汇编数据窗口，点击变量 |右击变量-Array| 按*键

如果它函数反编译出来的变量很奇怪，可以将这个函数undefine掉然后再define，这样看的变量就会正常很多

Alt+D, Setup Data types

#### 直接跳转EIP
![x](imgs/ida03.jpg)
### FAQ

#### F5提示：positive sp value has been found!!!!!“的解决方法/修复栈指针错误

[Link](https://blog.csdn.net/feibabeibei_beibei/article/details/85238676)

options->General->Disassembly->√Stack Pointer

在负值上一行Alt+K 输入0平衡栈
#### Decompilation failure: 401095: call analysis failed
这里分析出了问题，g 401095, 进入401095后F5再退出来F5就正常了。
#### 常见花指令处理与Patch

### 常用伪代码分析

int 80h,  中断
0x90 == nop

#### 连续的Char可能=String

    CHAR String; // [esp+34h] [ebp-20004h]
    char v19; // [esp+35h] [ebp-20003h]    =String[0]
    char v20; // [esp+36h] [ebp-20002h]    =String[1]
    char v21; // [esp+37h] [ebp-20001h]    =String[2]
    char v22; // [esp+38h] [ebp-20000h]    =String[3]
    char v23; // [esp+39h] [ebp-1FFFFh]    =String[4]
    char v24; // [esp+3Ah] [ebp-1FFFEh]    =String[5]
    char v25; // [esp+3Bh] [ebp-1FFFDh]    =String[6]
    char v26; // [esp+10034h] [ebp-10004h] =String[7]
    char v27; // [esp+10035h] [ebp-10003h] =String[8]
    char v28; // [esp+10036h] [ebp-10002h] =String[9]

相当于

    CHAR String[9]; // 上面地址也都是差1h

#### strcmp

strcmp(a,b) 相等时返回0,  `!strcmp(a,b)` 表示a,b相等为True

### IDAPython
示例 朱雀杯 tree
https://www.52pojie.cn/forum.php?mod=viewthread&tid=1181476


![IDAPython-7x_cheatsheet_web_en](imgs/IDAPython-7x_cheatsheet_web_en.png)

https://bbs.pediy.com/thread-260297.htm
[IDA从入门到乞讨之IDAPython Script 与 plugin](https://bbs.pediy.com/thread-269643.htm)

[IDAPython入门教程 基于IDA7.5_Python3 第一讲 简介与地址获取 ](https://www.cnblogs.com/iBinary/p/14642662.html)
#### 常用函数
https://www.hex-rays.com/products/ida/support/idapython_docs/

```python
idaapi.get_highlighted_identifier()  #屏幕高亮处
```

旧的函数   | 新的函数
- | -
Byte(addr) | idc.get_wide_byte(addr)
Word(addr) | idc.get_wide_word(addr)
Dword(addr)| idc.get_wide_dword(addr)
Qword(addr)| idc.get_qword(addr)

#### 执行Python脚本
https://www.hex-rays.com/products/ida/support/idapython_docs/

Description|Menu|Windows
--|--|--
执行Python脚本| `File - Sript File` | <kbd>Alt</kbd><kbd>F7</kbd>
Python命令窗口| `File - Sript Command` <br>Script Language选Pyhon| <kbd>Shift</kbd><kbd>F2</kbd>


#### 大端与小端 

假设一个十六进制数0x12345678

大端的存储方式是：12,34,56,78，然后读取的时候也是从前往后读

小端的存储方式是：78,56,34,12，然后读取的时候是从后往前读取

### FAQ
Q: 怎样从伪代码(F5)返回到 汇编代码
A: 按tab, 右击图 text view

Q: IDA，怎样在图(Proximity Browser)中展开显示子函数的汇编
A: space键 : 切换 graph view 和 text mode

### 快捷键

Esc 后退
Tab 切换伪代码和汇编

Enter 进入

G jump to address

Ctrl+P jump function

Shift+F12 查看文本

F5 反汇编成代码

Ctrl+X 查看调用

C 显示为代码

A 显示为String

Space 切换视图

显示为Array：　双击变量，进入反汇编窗口按*
### 变量显示

翻译
    
    A[(unsigned __int8)((unsigned __int8)B[i] / 3u - 2)] ) 等于
    A[B[i] / 3 - 2]

![123](./imgs/ida_1.png)

注意 0x6c和 0x68也要包含进来

    a = 'lk2j9Gh}AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX{CMt8SZo]'
    b = [0x48, 0x5D, 0x8D, ..., 0x1B, 0, 0]

#### 快速选中连续的bytes
定位好后，Ctrl+1, hex dump, 然后再选
#### 如何查看 函数地址
在函数窗口选中函数后 Ctrl+E
### 使用 Patch Program
1.伪代码窗口中 选中要使用Patch的位置，

    1.1 直接Ctrl+Alt+K 或
    1.2 按Tab, 进入反汇编窗口,  菜单 Edit-KeyPatch (Ctrl+Alt+K)
    1.2.1 或 反汇编窗口 Edit-"Patch Program"-Assemble

2. 修改，菜单 Edit-"Patch Program" - Apply Patches to input file.

### 使用远程调试, 调试windows程序和linux程序相同。

Windows 下的 IDA     

1. 在 IDA 的安装目录/dbgsrc/找到 linux_server 和 linux_serverx64 拷贝到 linux 虚拟机中
2. 在 linux 中运行 linux_server 并在 linux 中运行要调试的 demo
3. Debugger -- Attach -- Remote Linux debbuger

4. 配置客户端调试选项

路径默认是 linux_server 的位置, 放在同文件夹下可直接使用文件名。 否则使用全路径名。 / 开头

比如, /mnt/hgfs/vmware/dbg/runthis 或直接使用 runthis

配置好调试的服务端后，接下来开始配置客户端IDA，正常启动IDA打开【Debugger】-【Run】-【Remote Linux debugger】来设置调试选项

Debugger - Process Option

![Alt text](imgs/ida01.png)

__调试win下程序__

也使用远程的方式调试。

#### 调试常用

Description|Key binding
--|--
Step into|<kbd>F7</kbd>
Step over|<kbd>F8</kbd>

菜单 `Debugger - Debugger Windows - Watch View`


## android apk, java / 动态调试
[DASCTF八月挑战赛 Android 逆向 apkrev](https://mp.weixin.qq.com/s/Z26uEKDtmhnXapscWEEHSQ)

jadx打开。关键函数有native--表示反编译so文件。

[动态调试apk](https://the_itach1.gitee.io/2021/08/02/D0g3比赛平台 re wp/#极客巅峰-medical-app)
https://www.cnblogs.com/ddms/p/8820044.html
https://blog.csdn.net/freeking101/article/details/106701908
[2](https://blog.csdn.net/freeking101/article/details/106701908)
https://bbs.pediy.com/thread-269252.htm
https://bbs.pediy.com/thread-269320.htm

android 可以在strings.xml中找到字符串的值。

ida android 调试 [L1](https://www.jianshu.com/p/16e9966817c5)  [L2](https://www.jianshu.com/p/16e9966817c5)

例雷电模拟器 调试 Android 逆向 apkrev
1.使用模拟器的adb,安装ida的对应server

```
adb push android_x86_server /data/local/tmp
adb shell
/ # su
/ # cd /data/local/tmp
/data/local/tmp # ll
/data/local/tmp # chmod 777 android_x86_server
/data/local/tmp # ./android_x86_server
```
2.再建一个 cmd 命令行窗口，使用 forward 程序进行端口转发：

```
C:\Users\admin>adb forward tcp:23946 tcp:23946
23946
 
adb forward --list
emulator-5554 tcp:23946 tcp:23946
```

4、打开 IDA，选择菜单 Debugger -> Attach -> Remote Linux debugger；

Hostname 设置为 127.0.0.1，OK；


选择要附加的进程，找到 com.example.re，OK；

进入调试界面后，在右侧 Modules 窗口搜索需要调试的库：libnative-test.so；


### navtive 相关

关键函数有native。用ida在x86打开对应的文件。（如果不行再用x64的。）

```java
public native boolean myCheck(String str); // so用ida打开搜索 myCheck函数

static {
    System.loadLibrary("native-test"); // 读取 native-test.so
}
```

### 简单加壳 梆梆安全加固

https://blog.csdn.net/lostnerv/article/details/106040085

### 安卓逆向之H5类型app逆向
https://www.bilibili.com/video/BV1B34y117PX

xposed - WebViewDebugHook, 

`VHook不知道干啥的`

然后在Chrome 打开  chrome://inspect/#devices , 刷新一下。
APP端退出再进入。Chrome处多一个框框。点击对应页面 inspect.
有可能需要上一层跟进
## java 反编译

### jd-gui
Bug: 如果打不开class文件，多半是类名和文件名不一致。可以先新建一个hi.java，然后把class文件放到此文件夹，用jd-gui打开 hi.java， class文件就能正常显示了。

### Jeb
拉进入后，右击main, 解析(Decompiler)

### anrdoid killer
重新打包-- 菜单-android 批量编译

### Android reverse
[由2021ByteCTF引出的intent重定向浅析](https://mp.weixin.qq.com/s/A8g7cIyM480Y_gXFwiGjMg)

#### IDA基本用法
https://www.bilibili.com/video/BV1BR4y1J7Hf

jadx 打开，保存后。 源文件

```
System.loadLibrary("wtf");
public static native String getSign(String arg0, String arg1, String arg2)

```
会加载 libwtf.so 文件。 native关键字,表示从so中导出的getSign方法, 用ida载入so文件

1. Export窗口。有 `Java_com_sichuanol_cbgc_util_SignManager_getSign` ,前面是包名后面是类名+方法名

2. File - Load File - Parse C header file(Ctrl+F9), 载入 jni.h
3. 选择参数1即a1, Convert to struct *
4. 选择_JNIEnv

#### jni, native关键字和so文件

https://blog.csdn.net/re_psyche/article/details/83790851
https://blog.csdn.net/getsum/article/details/85217885

解压后用jeb打开mainactivity， 解析，调用了 hellolib

发现关键函数是 native 的，所以要查看hellolib.so文件。

jeb里找到后用16进制查看。向下翻页找DDCTF****@***.com 即flag.（或者winhex打开，然后搜索ctf找到flag）

```
MD5Digest(v18, v22, v30)  // 输入, 长度 输出, C语言中通常不用返回值
```
#### IDA动态调试APK

https://www.bilibili.com/video/BV1W3411y7tD

```
adb push android_server /data/local/tmp
adb shell
su
cd /data/local/tmp
chmod 777 android_server
./android_server

// 换窗口
adb forward tcp:23946 tcp:23946
```

IDA , Debugger - Attach - Remote Arm Linux/Android debugger, 勾选

```
Suspend on process entry poiont
Suspend on thread start/exit
Suspend on library load/unload
```

确定， hostname: 127.0.0.1

选择要调试的APK确定

查看 Modules窗口，找到对应的so文件双击。

双击方法名称。

动态时会隐藏函数名，所以还开2个IDA一个看地址及函数名称。

下断点，执行 断下后。。

在hex view, syncronize with r0

寄存器窗口  通常R0-R3 参数 R4-R8局部变量 LR返回地址 PC当前位置 SP栈顶

## Ollydbg
插件-搜索-中文-unicode  里面找有没有你赢了，flag等相关字，
[调试子进程](https://blog.csdn.net/darcy_123/article/details/101552444)

bp printf # printf 断点

### FAQ
Q:如何加入参数调试？

A:菜单:调试-参数

Q: 怎样删除硬件断点？ 

A: 调试-硬件断点
### 快捷键

快捷键|说明
--|--
F4|运行到光标位置
F2|断点
Ctrl+G|转到表达式 400001
Ctrl+S|查找命令序列
Ctrl+B|查找二进制
1-9| NOP 1-9个字节
Alt+Bksp|撤销修改

寄存器窗口 Z 位关系到跳转

左下角 M1-M5

      记录你当前内存操作最后一次的位置及 显示格式    
      选中M1  ： dd  00401000 
      选中M2：  db 00401020 
      选中M3：  让内存以字符串形式显示 
      接着你切换 M1 M2 M3就发现内存的显示

条件断点

    eax == 040000
    eax == 25 , 表示的是 0x25
    堆栈窗口右击-地址-相对于ESP，如要记录Conditional_bp.exe调用CreateFileA函数的情况，在CreateFileA函数的第一行，按Shift+F4键 [STRING[ESP+4]]=="c:\\1212.txt"
    CreateFIleW函数地址处，按下Shift+F2，输入条件：[UNICODE[esp+4]]=="C:\\Test\\123.txt"

### 条件断点

Shift+F2, eax == 0400000
### TODO
是否支持

    bp main
    bp kernel32!createprocess
    bp [apiname]

## x64dbg
插件xanalyzer
   plugin或右键, analyze selection / module

设置-系统断点，×，即可断在程序开始处

按g，显示流程图

保存修改: file-patch file

sync command: 流程图 右击 sync with origin

going back into the stpped in call: 流程图 按SS 

[trace recording]
    
    方便观察走了哪些路径，便于分析
    trace --> trace record --> word
    then, step over line by line(F8)

## angr 二进制框架

[L1](https://blog.csdn.net/xiangshangbashaonian/article/details/82825488) [L2](https://www.freebuf.com/sectool/143056.html)

__示例1: WhaleCTF题目 r100__

```python
import angr
proj = angr.Project("./r100",auto_load_libs=False)
state = proj.factory.entry_state()
simgr = proj.factory.simgr(state) 
simgr.explore(find=0x400844,avoid=0x400855) # 0x400844 =>输出正确答案的地址, 0x400855 错误跳转到erorr的地址
a = simgr.found[0].posix.dumps(0)
print(a) # 直接跑出答案
```

__示例2:  [ais3_crackme](https://github.com/angr/angr-doc/raw/master/examples/ais3_crackme/ais3_crackme)__

这个是需要跟参数的, 

通过claripy模块，来构造输入。claripy是一个符号求解引擎和z3类似，我们完全可以将其当成是z3进行使用。

claripy关于变量的定义在claripy.ast.bv.BV当中

通常使用claripy.BVS()创建位向量符号

```python
import angr   #导入angr
import claripy    #导入claripy
proj = angr.Project("./ais3_crackme")    #载入文件
argv1 = claripy.BVS('argv1',50*8)    #B是bit 1字节=8bit  猜测输入不多于50字节 就是50*8
state = proj.factory.entry_state(args=['./ais3_crackme',argv1])
simgr = proj.factory.simgr(state)
simgr.explore(find=0x400602,avoid=0x40060E)    #成功位置及失败位置
print(simgr.found[0].solver.eval(argv1))    #转成ascll码输出
print(simgr.found[0].solver.eval(argv1,cast_to=bytes))    #直接输出字符

```

## 脱壳、常见壳
### 去除随机地址ASLR

Stud_PE载入后， 左下角，最下面。dll特征 - 点击+号 - 动态基址 去√

### upx壳 esp定律

kali中自带 `upx -d filename`

手动脱壳1

    直接CTRL+F，输入popad
    0040EA0E     61            popad                 //F2下断，F9运行，F2取消断点，单步F8
    0040EA0F   - E9 B826FFFF   jmp NOTEPAD.004010CC

手动脱壳1-esp定律

遇到向上跳转的jz等向上跳循环，直接移到下一行F4.

F8单步找到 pushad的下一句，看右侧寄存器窗口ESP变红，

1.右击ESP - HW Break [ESP]

    方式 1.1 或在数据窗口跟随，此时，在数据窗口中，右单击“数值”，选择“断点”->“设置硬件访问断点”->“Word”，按 Shift+F9
    方式 1.2 https://www.52pojie.cn/forum.php?mod=viewthread&tid=314918
    1.2.1 或 来到pushad语句后， 在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值）
    1.2.2 hr ESP(关键标志下一行代码所指示的ESP值(单步通过))
    x64dbg: bphc删除断点
    x64dbg:  bph rsp,w,4

2.F9运行。继续单步，直到下一行是JMP之类的跳过去，看到像程序入口的地方,右击，用ollydump脱壳将程序DUMP出来即可，如

      0040EA0F   - E9 B826FFFF     jmp UPX.004010CC
      0040EA14     0000            add byte ptr ds:[eax],al
      0040EA16     0000            add byte ptr ds:[eax],al
      0040EA18     0000            add byte ptr ds:[eax],al
      0040EA1A     0000            add byte ptr ds:[eax],al
      0040EA1C     0000            add byte ptr ds:[eax],al
    
     此时，再按F8,便来到了OEP处，DUMP程序。
     如果没到OEP, 搜索字符串如 input:, 定位到程序领空向上找到入口点。

3. 如果脱壳后不能动调



## Python
### Python/pyd

https://www.bilibili.com/video/ magic
先import magic, 然后dir(magic)看有哪些奇怪的调用一下。

### Python/pyc/pyinstaller
视频 https://www.bilibili.com/video/BV1JL4y1p7Tt

http://81.70.81.64/dasctf%E5%85%AB%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwriteup/#toc-head-3
https://www.cnblogs.com/pluie/p/13621823.html
https://blog.csdn.net/weixin_35967330/article/details/114390031

pyc可以直接python x.pyc运行

1. `python pyinstxtractor.py 1py.exe` 看是什么版本, 
2. 有pyz/pyd文件加密时需要对应的python版本解密, 见下面
2. 可能要补或改magic code为显示的版本。
         可以看struct文件的第一行

查看 pyc 对应的python版本 Linux: `file filename.pyc`

python源码的 Python-3.x.x/Lib/importlib/_bootstrap_external.py
https://github.com/google/pytype/blob/master/pytype/pyc/magic.py

https://blog.csdn.net/weixin_46263782/article/details/120939260

[格式详解](https://kdr2.com/tech/main/1012-pyc-format.html)
[格式详解](https://www.cnblogs.com/blili/p/11799483.html)
[py2示例](http://www.xumenger.com/01-python-pyc-20180521/)

看Magic Code可知是py2还是py3
```
42 0D 0D 0A 00 00 00 00 00 47 79 61 33 00 00 00
Maigc Code |           |33617947时间戳| TYPE_CODE字段，见marshal.c
E3 00 00 00 00 00 00 00 00 00 00 00 00 03 00 00
00 40 00 00 00 73 1E 00 00 00 65 00 64 00 64 01
83 02 5A 01 65 01 A0 02 A1 00 5A 03 65 04 65 03
83 01 01 00 64 02 53 00 29 03 7A 05 78 78 2E 70
```

PyCodeObject对象----code block:
```
1个字节0x73为TYPE_CODE字段， 表示该字段为string格式；
4个字节0x1E00 0000表示code block段的数据部分占用0x1E个字节，即长度为30；
接下来30个字节65006400 ...... 5300 为该TYPE_CODE字段（数据类型string）部分，也就是pyc文件中包含的字节码指令
再往下的逐个TYPE_CODE字段都是重复结构的，用来表示PyCodeObject对象中的一些其他参数
```

见 `## pyc | DASCTF Oct X 吉林工师 欢迎来到魔法世界～ 魔法叠加`
#### pyc/asm/print mashal code

```python
def print_code(filename):
    import marshal
    f = open(filename, 'rb')
    code = marshal.loads(f.read())
    print(code)
```
编译Pyc

```py
python -m py_compile main.py
```

pydisasm.exe a.pyc

#### pyz/pyd 文件
用相同版本反编译会出pyz
https://www.jianshu.com/p/b5404e65416d
https://miaotony.xyz/2021/10/25/CTF_2021bailu/#toc-heading-5
原理  https://bbs.pediy.com/thread-271253.htm

1.安装pyinstaller, 找到 pyimod02_archive.py复制到程序根目录， 在文件最后面写入内容，执行解密文件变成pyc。
```python
inf = open(r'PYZ-00.pyz_extracted\baby_python\baby_core.pyc.encrypted', 'rb')
c = Cipher()

buf = c.decrypt(inf.read())
buf = zlib.decompress(buf)

out = open(r'PYZ-00.pyz_extracted\baby_python\baby_core.pyc', 'wb')
out.write(buf)
print('written down %d bytes' % len(buf))

inf.close()
out.close()
```
2.添加文件头
3.uncompyle6解密Pyc文件

##### pyd文件
PYD是 Cpython实现的文件。看起来和dll一样
[浅谈pyd文件逆向](https://tttang.com/archive/1641/)

1.直接搜字符串
2.通过爆破。

#### pyc/去花指令
[Python3 字节码混淆 ](https://blog.csdn.net/weixin_46263782/article/details/120939260)

1.先输出bytecode, 再到opcode.h中查找对应的码。
2.删除相关码
3.修改长度。 `len(co_code) - n`
方式2 pycdc

[VNCTF2022 BabyMaze](https://www.bilibili.com/video/BV1ka411k7td)
https://www.cnblogs.com/wgf4242/p/15921454.html
https://ppppz.net/2022/02/08/BabyMaze/
1 -
```py
import marshal,dis
f = open('BabyMaze.pyc', 'rb').read()
code = marshal.loads(f[16:]) # py3长度16， py2是长度8
code
dis.dis(code)
print(len(code.co_code)) # 2030
```
2
```
  1           0 JUMP_ABSOLUTE            4     花
        >>    2 JUMP_ABSOLUTE            6     花
        >>    4 JUMP_ABSOLUTE            2     花
        >>    6 LOAD_CONST               0 (1)
        >>    
```
3 python38\include\opcode.h
```
#define JUMP_ABSOLUTE           113 # 71
去掉 71 04 71 06 71 02 , 长度为6
```
4.去掉花的同时也要改co_code，这个是记录字节码的长度，所以我们减去6个这个也要减6 -- 2030 - 6 = 2024，
将 ee 07改为e8 07
5. uncompyle6 -o x.py BabyMaze.pyc

### 编译一个pyc
```sh
python -m compileall .
python -m compileall main.py
python -m py_compile main.py
```

## dotnet/unity
dnspy打开文件, 重点分析这个 Assembly-CSharp.dll

[使用dnspy动态调试发行的unity游戏代码](https://bobh.mkaliez.com/archives/use-dnspy-to-debug-unity-code.html)
https://github.com/dnSpy/dnSpy/wiki/Debugging-Unity-Games

Android版本
resources\assets\bin\Data\Managed\Assembly-CSharp.dll

## Firmware
安装 firmware-mod-kit

```sh
sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic
git clone https://github.com.cnpmjs.org/mirror/firmware-mod-kit.git
cd firmware-mod-kit/src
./configure && make
cd ..
```
解压
```sh
cd ~/vmware
~/Downloads/firmware-mod-kit/unsquashfs_all.sh ~/vmware/120200.squashfs
```
一般在tmp,bin找到文件，检测脱壳后，直接IDA载入。
比如查找 server, 直接在 Disassemble View下Alt+T, √Find all occrurence, server。

## Wiki
### 内存相关知识 

扩展的存储单位有：

计算机存储容量大小以字节数来度量，1024进位制：

    1024B=1K(千)B  
    1024KB=1M(兆)B 
    1024MB=1G(吉)B 
    1024GB=1T(太)B 

　　 这是常用的五个，至于PB，EB，ZB，YB，BB，NB，DB几乎在日常使用中是不会遇到的。

　　

而Int8，Int16，Int32，nt64，后面的数字就代表这个数据类型占据的空间。

    Int8, 等于Byte, 占1个字节.
    Int16, 等于short, 占2个字节. -32768 32767
    Int32, 等于int, 占4个字节. -2147483648 2147483647
    Int64, 等于long, 占8个字节. -9223372036854775808 9223372036854775807

样, 看起来比short,int,long更加直观些!

　　另外, 还有一个Byte, 它等于byte, 0 - 255.

### 常见语言的入口点


VB：

    004012D4 >  68 54474000     push QQ个性网.00404754
    004012D9    E8 F0FFFFFF     call <jmp.&MSVBVM60.#100>
    004012DE    0000            add byte ptr ds:[eax],al
    004012E0    0000            add byte ptr ds:[eax],al
    004012E2    0000            add byte ptr ds:[eax],al
    004012E4    3000            xor byte ptr ds:[eax],al
    004012E6    0000            add byte ptr ds:[eax],al
    004012E8    48              dec eax



import base64
b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'   #导入base64能表示的所有值
with open('E:/ctf/xctf/杂项/7.zip伪加密+base64隐写/a2eb7ceaf5ab49f7acb33de2e7eed74a (1)/stego.txt', 'rb') as f:#打开二进制文件
    bin_str = ""
    flag = ""   
    for line in f.readlines():
        stegb64 = str(line, "utf-8").strip("\n")
        # 解码再编码后，得到隐写前的 Base64编码
        rowb64 = str(base64.b64encode(base64.b64decode(stegb64)), "utf-8").strip("\n")
        # 两次编码的末尾的数据会存在差异，主要是由于 Base64 隐写将一部分二进制码 存到了 在编码过程中会被丢弃的二进制码中
        # 我们要做的就是把被舍弃的那一部分的二进制码找出来并拼接，转换，找出二进制码所表示的字符串
        # 查找每一种编码的最后一个字符的所在位置的差异 => 将会得到 相差的位数，将位数转化成二进制码即可得到被隐写的那一部分的二进制码
        offset = abs(b64chars.index(stegb64.replace('=', '')[-1]) - b64chars.index(rowb64.replace('=', '')[-1]))
        # 每一行的 ‘=’ 的个数 => 得到补充 0 的位数
        # 一个 ‘=’ 表示 补了 两个二进制位
        # 两个 ’=‘ 表示 补了 四个二进制位
        # 这些二进制位可能存在被隐写的部分
        equalnum = stegb64.count('=')
        # 包含 ‘=’ 时 即 可能包含 Base64 隐写时
        if equalnum:
            # 将差异位 转换为 二进制 => 得到相应的二进制码并进行拼接
            # equalnum * 2 的意思为：添加的二进制位
            bin_str += bin(offset)[2:].zfill(equalnum * 2)
    # 将二进制文件转换为字符串
    for i in range(0, len(bin_str), 8):
        flag += chr(int(bin_str[i:i + 8], 2))
    print(flag)
:

    004A5C54 >  55              push ebp
    004A5C55    8BEC            mov ebp,esp
    004A5C57    83C4 F0         add esp,-10
    004A5C5A    B8 EC594A00     mov eax,openpro.004A59EC


BC++:

    00401678 > /EB 10           jmp short btengine.0040168A
    0040167A   |66:623A         bound di,dword ptr ds:[edx]
    0040167D   |43              inc ebx
    0040167E   |2B2B            sub ebp,dword ptr ds:[ebx]
    00401680   |48              dec eax
    00401681   |4F              dec edi
    00401682   |4F              dec edi
    00401683   |4B              dec ebx
    00401684   |90              nop
    00401685  -|E9 98005400     jmp 00941722
    0040168A   \A1 8B005400     mov eax,dword ptr ds:[54008B]
    0040168F    C1E0 02         shl eax,2
    00401692    A3 8F005400     mov dword ptr ds:[54008F],eax
    00401697    52              push edx
    00401698    6A 00           push 0
    0040169A    E8 99D01300     call <jmp.&KERNEL32.GetModuleHandleA>
    0040169F    8BD0            mov edx,eax


VC++:

    0040A41E >  55              push ebp
    0040A41F    8BEC            mov ebp,esp
    0040A421    6A FF           push -1
    0040A423    68 C8CB4000     push 跑跑排行.0040CBC8
    0040A428    68 A4A54000     push <jmp.&MSVCRT._except_handler3>
    0040A42D    64:A1 00000000  mov eax,dword ptr fs:[0]
    0040A433    50              push eax
    0040A434    64:8925 0000000>mov dword ptr fs:[0],esp
    0040A43B    83EC 68         sub esp,68
    0040A43E    53              push ebx
    0040A43F    56              push esi
    0040A440    57              push edi


MASM(汇编):

    004035C9 >  6A 00           push 0
    004035CB    E8 A20A0000     call <jmp.&kernel32.GetModuleHandleA>
    004035D0    A3 5B704000     mov dword ptr ds:[40705B],eax
    004035D5    68 80000000     push 80
    004035DA    68 2C754000     push 11.0040752C
    004035DF    FF35 5B704000   push dword ptr ds:[40705B]
    004035E5    E8 820A0000     call <jmp.&kernel32.GetModuleFileNameA>
    004035EA    E8 87070000     call 11.00403D76
    004035EF    6A 00           push 0
    004035F1    68 0B364000     push 11.0040360B
    004035F6    6A 00           push 0
    004035F8    6A 64           push 64
    004035FA    FF35 5B704000   push dword ptr ds:[40705B]

### C 语言符号优先级

| 表2 运算符优先级和结合律                                 |                                                              |          |
| -------------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 优先级                                                   | 运算符                                                       | 结合律   |
| 1                                                        | 后缀运算符：[]   ()   ·     ->   ++   --(类型名称){列表}     | 从左到右 |
| 2                                                        | 一元运算符：++     --   !   ~    +   -   *   &     sizeof_Alignof | 从右到左 |
| 3                                                        | 类型转换运算符：(类型名称)                                   | 从右到左 |
| 4                                                        | 乘除法运算符：*   /   %                                      | 从左到右 |
| 5                                                        | 加减法运算符：+   -                                          | 从左到右 |
| 6                                                        | 移位运算符：<<   >>                                          | 从左到右 |
| 7                                                        | 关系运算符：<<=   >>=                                        | 从左到右 |
| 8                                                        | 相等运算符：==   !=                                          | 从左到右 |
| 9                                                        | 位运算符 AND：&                                              | 从左到右 |
| 10                                                       | 位运算符 XOR：^                                              | 从左到右 |
| 11                                                       | 位运算符 OR：\|                                              | 从左到右 |
| 12                                                       | 逻辑运算符 AND：&&                                           | 从左到右 |
| 13                                                       | 逻辑运算符 OR：\|\|                                          | 从左到右 |
| 14                                                       | 条件运算符：?:                                               | 从右到左 |
| 15                                                       | 赋值运算符：                                                 | 从右到左 |
| | =       +=     -=    *=   /=    %=    &=     ^=    \|= |                                                              |       
| | <<=      >>=                                           |                                                              |       
| 16                                                       | 逗号运算符：，                                               | 从左到右 |

## 加密算法
### 算法表 alg-id
https://blog.csdn.net/qq_53532337/article/details/121275061
CryptCreateHash
CryptHashData
https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id
CryptCreateHash(proc, 0x8003u,...)  0x8003为md5
### rc4
把 enc 用key再跑一遍即可

### AES
https://blog.csdn.net/heyatzw/article/details/76165635
https://blog.csdn.net/abel_big_xu/article/details/115703082

动画 https://www.bilibili.com/video/BV1HK4y1s7Np?from=search&seid=14517523810350865187
密钥扩展
```c
__int64 __fastcall sub_402219(__int64 a1)
{
  unsigned int v2; // [rsp+18h] [rbp-D8h]
  int i; // [rsp+1Ch] [rbp-D4h]
  char v4[200]; // [rsp+20h] [rbp-D0h] BYREF
  unsigned __int64 v5; // [rsp+E8h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  sub_400A71((__int64)v4, (__int64)&unk_603170);// 轮密钥生成
                                                // unk_603170为初始密钥
                                                // v4为生成的轮密钥
  sub_40196E((__int64)v4, a1);                  // 前16位AES加密
  sub_40196E((__int64)v4, a1 + 16);             // 后16位AES加密
  v2 = 1;
  for ( i = 0; i <= 31; ++i )
  {
    if ( *(_BYTE *)(i + a1) != byte_6030A0[i] )
      v2 = 0;
  }
  return v2;                                    // 返回v2 存放在EAX中
}


__int64 __fastcall sub_401828(__int64 a1, __int64 a2)
{
  unsigned __int8 i; // [rsp+1Fh] [rbp-1h]

  sub_400B0A(0LL, a1, a2);                      // 轮密钥加
  for ( i = 1; i <= 9u; ++i )
  {
    sub_400BAC(a1);                             // S盒字节代换
    sub_400C1F(a1);                             // 行移位操作
    sub_400D27(a1);                             // 列混合操作
    sub_400B0A(i, a1, a2);
  }
  sub_400BAC(a1);
  sub_400C1F(a1);
  return sub_400B0A(10LL, a1, a2);              // 进行10轮加密
}
```
## cpp/c++

ostream 输出流,可重载操作符
https://blog.csdn.net/luoyayun361/article/details/87972929

### 练习

[writeup](writeup/xctf_game.md)

[xctf_NJUPT CTF 2017_maze.md](writeup/xctf_NJUPT CTF 2017_maze.md)

# CTF特训营

## 10.1 常规分析

### API断点

GetWindowText和GetDlgItemText

### 10.1.2 常见加密法识别

#### TEA

固定常数 0x9e3779b9 或 0x61c88647 或一个大数吧

#### rc4 流密码

加解密用一个函数 再跑一下密文即可

```c
// 初始化函数
void rc4_init(unsigned char *s,unsigned char *key, unsigned long Len) {
    int i = 0, j = 0;
    // char k[256]={0};
    unsigned char k[256] = {0};
    unsigned char tmp = 0;
    for (i = 0; i < 256; i++) {
        s[i] = i;
        k[i] = key[i % Len];
    }
    for (i = 0; i < 256; ++i) {
        j = (j + s[i] + k[i]) % 256;
        tmp = s[i];
        s[i] = s[j]; // 交换 s[i] 和 s[j]
        s[j] = tmp;
    }
}

/* 加解密 */
void rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len){
    int i = 0, j = 0, t = 0;
    unsigned long k = 0;
    unsigned char tmp;
    for (k = 0; k < Len; ++k) {
        i = (i+1) % 256;
        j = (j + s[i]) % 256;
        tmp = s[i];
        s[i] = s[j]; // 交换 s[i] 和 s[j]
        s[j] = tmp;
        t = (s[i] + s[j]) % 256;
        Data[k] ^= s[t];
    }
}
```
#### MD5

关键字
0x67452301
0xefcdab89
0x98badcfe
0x10325476

### 10.1.3 求解flag

#### 线性变换的求解

输入 1字节不同
123456
a23456
输出只有1字节不同时，确定为线性变换。。可以进行单字节爆破。
#### 约束求解

z3
# CTF从0到1

## 逆向

### 基础 
#### 调用约定
（1）x86 32位架构的调用约定
* __cdecl：参数从右向左依次压入栈中，调用完毕，由调用者负责将这些压入的参数清理掉，返回值置于EAX中。绝大多数×86平台的C语言程序都在使用这种约定。
* __stdcall：参数同样从右向左依次压入栈中，调用完毕，由被调用者负责清理压入的参数，返回值同样置于EAX中。Windows的很多API都是用这种方式提供的。
* __thiscall：为类方法专门优化的调用约定，将类方法的this指针放在ECX寄存器中，然后将其余参数压入栈中。
* __fastcall：为加速调用而生的调用约定，将第1个参数放在ECX中，将第2个参数放在EDX中，然后将后续的参数从右至左压入栈中。

（2）x86 64位架构的调用约定

* Microsoft x 64位（x 86-64）调用约定：在Windows上使用， 依次将前4个参数放入RDI、RSI、RDX、RCX这4个寄存器， 然后将剩下的参数从右至左压入栈中。
* SystemV x64调用约定：在Linux、MacOS上使用， 比Microsoft的版本多了两个寄存器使用RDI、RSI、RDX、RCX、R8、R9这6个寄存器传递前6个参数， 剩下的从右至左压栈。


# 编程部分
## Python调用C

pip install xxtea-py 见源码。
